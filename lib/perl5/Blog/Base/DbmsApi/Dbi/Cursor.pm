package Blog::Base::DbmsApi::Dbi::Cursor;
use base qw/Blog::Base::DbmsApi::Cursor/;

# Generated by CoTeDo - DO NOT EDIT!

use strict;
use warnings;

use Blog::Base::Array;

# -----------------------------------------------------------------------------

=encoding utf8

=head1 NAME

Blog::Base::DbmsApi::Dbi::Cursor - DBI Datenbank-Cursor

=head1 BASE CLASS

L<Blog::Base::DbmsApi::Cursor>

=head1 IMPORT

L<Blog::Base::Array>

=head1 DESCRIPTION

Ein Objekt der Klasse repräsentiert einen DBI-Datenbank-Cursor.

=head1 ATTRIBUTES

=over 4

=item sth => $sth

DBI Statement-Handle.

=item bindVars => $n

Anzahl an Bind-Variablen, die im Statement enthalten sind. Ist
die Anzahl größer 0, handelt es sich um einen Bind-Cursor.

=item titles => \@titles

Array der Kolumentitel. Ist das Array nicht leer, handelt es
sich um einen Select-Cursor.

=item hits => $n

Anzahl der getroffenen Datensätze.

=item id => $id

Id nach INSERT in Tabelle mit AUTOINCREMENT-Kolumne (MySQL, SQLite)

=back

=head1 METHODS

=head2 Konstruktor/Destruktor

=head3 new()

=cut

# -----------------------------------------------------------------------------

sub new {
    my $class = shift;

    my $self = $class->SUPER::new(
        sth=>undef,
        bindVars=>0,
        bindTypes=>bless([],'Blog::Base::Array'),
        db=>undef,
        titles=>[],
        hits=>0,
        id=>0,
    );
    $self->lockKeys;

    $self->set(@_);

    return $self;
}

# -----------------------------------------------------------------------------

=head3 destroy()

=cut

# -----------------------------------------------------------------------------

sub destroy {
    my ($self) = @_;

    if (my $sth = $self->{'sth'}) {
        $sth->finish;
    }
    $_[0] = undef;

    return;
}

# -----------------------------------------------------------------------------

=head2 Accessors

=head3 bindVars()

=cut

# -----------------------------------------------------------------------------

sub bindVars {
    return shift->{'bindVars'};
}

# -----------------------------------------------------------------------------

=head3 bindTypes()

=cut

# -----------------------------------------------------------------------------

sub bindTypes {
    my $self = shift;
    # @_: @types

    my $arr = $self->{'bindTypes'};
    if (@_) {
        @$arr = ();
        my $dbms = $self->{'db'}->{'dbms'};
        for my $type (@_) {
            if (!defined $type) {
                push @$arr,undef;
            }
            elsif ($type eq 'BLOB') {
                if ($dbms eq 'oracle') {
                    push @$arr,{ora_type=>DBD::Oracle::SQLT_BIN()};
                }
                elsif ($dbms eq 'postgresql') {
                    push @$arr,{pg_type=>DBD::Pg::PG_BYTEA()};
                }
                else {
                    push @$arr,undef;
                }
            }
            elsif ($type eq 'TEXT') {
                if ($dbms eq 'oracle') {
                    push @$arr,{ora_type=>DBD::Oracle::SQLT_CHR()};
                }
                else {
                    push @$arr,undef;
                }
            }
            else {
                push @$arr,$type;
            }
        }
    }

    return wantarray? @$arr: $arr;
}

# -----------------------------------------------------------------------------

=head3 hits()

=cut

# -----------------------------------------------------------------------------

sub hits {
    return shift->{'hits'};
}

# -----------------------------------------------------------------------------

=head3 id()

=cut

# -----------------------------------------------------------------------------

sub id {
    return shift->{'id'};
}

# -----------------------------------------------------------------------------

=head3 titles()

=cut

# -----------------------------------------------------------------------------

sub titles {
    return shift->{'titles'};
}

# -----------------------------------------------------------------------------

=head2 Miscellaneous

=head3 bind()

=cut

# -----------------------------------------------------------------------------

sub bind {
    my $self = shift;

    my ($sth,$bindVars,$bindTypes) = $self->get(qw/sth bindVars bindTypes/);

    my $hits = 0;
    while (@_) {
        my @vals;
        if (ref $_[0]) {
            # Wert ist (Array-)Referenz, wir expandieren die Referenz
            @vals = @{shift()}
        }
        else {
            # Abfolge von Werten
            @vals = splice @_,0,$bindVars;
        }

        # '' auf undef umsetzen

        for (@vals) {
            if (defined $_ && $_ eq '') {
                $_ = undef;
            }
        }

        # Werte binden und Statement ausführen. BindType kann
        # undef sein. Im Falle von Oracle und BLOB oder CLOB sollte
        # ein Type spezifiziert sein (siehe Methode bindTypes)

        for (my $i = 0; $i < @vals; $i++) {
            $sth->bind_param($i+1,$vals[$i],$bindTypes->[$i]);
        }
        my $r = $sth->execute;
        $hits += $r if $r > 0;
    }
    $self->{'hits'} = $hits;

    # Die Kolumnentitel sind bei SELECT-Statements mit Bind-Variablen
    # erst nach dem Bind verfügbar.

    if ($sth->{'NUM_OF_FIELDS'}) {
        $self->{'titles'} = Blog::Base::Array->bless($sth->{'NAME_lc'});
    }

    return $self;
}

# -----------------------------------------------------------------------------

=head3 fetch()

=cut

# -----------------------------------------------------------------------------

sub fetch {
    my $self = shift;
    my $curName = shift;
    my $chunkSize = shift;
    my $chunkPosS = shift;

    if ($curName) { # PostgreSQL
        if ($$chunkPosS == $chunkSize) {
            my $stmt = "FETCH $chunkSize FROM $curName";
            my $cur = $self->{'db'}->sql($stmt,-log=>0);
            $self->{'sth'} = $cur->{'sth'};
            # $self->{'sth'} = $self->{'db'}->{'dbh'}->prepare($stmt);
            # $self->{'sth'}->execute;
            $$chunkPosS = 1; # nicht 0, da wir den ersten Satz unten fetchen!
        }
        else {
            $$chunkPosS++;
        }
    }

    my $row = $self->{'sth'}->fetchrow_arrayref;
    if ($row) {
        grep { $_ = '' if !defined $_ } @$row; # undef -> ''
    }

    return $row;
}

# -----------------------------------------------------------------------------

=head1 AUTHOR

Frank Seitz, L<http://fseitz.de/>

=head1 COPYRIGHT

Copyright (C) 2015 Frank Seitz

=cut

# -----------------------------------------------------------------------------

1;

# eof
