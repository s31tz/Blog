package Blog::Base::String;
use base qw/Blog::Base::Object/;

# Generated by CoTeDo - DO NOT EDIT!

use strict;
use warnings;

use Encode::Guess ();
use Encode ();
use Blog::Base::Option;

# -----------------------------------------------------------------------------

=encoding utf8

=head1 NAME

Blog::Base::String - Operationen auf Zeichenketten

=head1 BASE CLASS

L<Blog::Base::Object>

=head1 METHODS

=head2 Encoding

=head3 autoDecode() - Auto-dekodiere Zeichenkette

=head4 Synopsis

    $str = $class->autoDecode($str);

=head4 Description

Analysiere Zeichenkette $str hinsichtlich ihres Character-Encodings
und dekodiere sie entsprechend. Unterschieden werden:

    ASCII
    UTF-8
    UTF-16/32 mit BOM
    ISO-8859-1

Weitere Encodings werden I<nicht> erkannt, bzw. als ISO-8859-1 angesehen.

=cut

# -----------------------------------------------------------------------------

sub autoDecode {
    my ($class,$str) = @_;

    # Encoding ermitteln und Text dekodieren

    # $Encode::Guess::NoUTFAutoGuess = 1;
    my $dec = Encode::Guess->guess($str);
    if (ref $dec) {
        # Wir dekodieren Unicode
        $str = $dec->decode($str);
    }
    elsif ($dec =~ /No appropriate encodings found/i) {
        # Wir dekodieren ISO-8859-1
        $str = Encode::decode('iso-8859-1',$str);
    }
    else {
        # Unerwarteter Fehler
        $class->throw(
            q{PATH-00099: Zeichen-Dekodierung fehlgeschlagen},
            Message=>$dec,
        );
    }

    return $str;
}

# -----------------------------------------------------------------------------

=head2 Einrückung

=head3 removeIndent() - Entferne Text-Einrückung

=head4 Synopsis

    $str = $class->removeIndent($str,@opt); # [1]
    $class->removeIndent(\$str,@opt);       # [2]

=head4 Options

=over 4

=item -addNL => $bool (Default: 0)

Nach dem Entfernen aller NEWLINEs am Ende füge ein NEWLINE hinzu.

=back

=head4 Description

[1] Entferne Text-Einrückung aus Zeichenkette $str und liefere das
Resultat zurück.

[2] Wird eine Referenz auf $str übergeben, wird die
Zeichenkette "in place" manipuliert und nichts zurückgegeben.

=over 2

=item o

NEWLINEs am Anfang werden entfernt.

=item o

Whitespace (SPACEs, TABs, NEWLINEs) am Ende wird entfernt.
Das Resultat endet also grundsätzlich nicht mit einem NEWLINE.

=item o

Die Methode kehrt zurück, wenn $str anschließend nicht mit wenigstens
einem Whitespace-Zeichen beginnt, denn dann existiert keine
Einrückung, die zu entfernen wäre.

=item o

Die Einrückung von $str ist die längste Folge von SPACEs
und TABs, die allen Zeilen von $str gemeinsam ist,
ausgenommen Leerzeilen. Diese Einrückung wird am Anfang
aller Zeilen von $str entfernt.

=item o

Eine Leerzeile ist eine Zeile, die nur aus Whitespace besteht.

=back

=head4 Example

=over 2

=item *

Einrückung entfernen, Leerzeile übergehen:

    |
    |  Dies ist
    |              <- Leerzeile ohne Einrückung
    |  ein Test-
    |  Text.
    |

wird zu

    |Dies ist
    |
    |ein Test-
    |Text.

=item *

Tiefere Einrückung bleibt bestehen:

    |
    |    Dies ist
    |  ein Test-
    |  Text.
    |

wird zu

    |  Dies ist
    |ein Test-
    |Text.

=back

=cut

# -----------------------------------------------------------------------------

sub removeIndent {
    my $class = shift;
    my $arg = shift;
    # @_: @opt

    my $ref = ref $arg? $arg: \$arg;

    my $addNL = 0;

    if (@_) {
        Blog::Base::Option->extract(\@_,
            -addNL=>\$addNL,
        );
    } 

    if (defined $$ref) {
        $$ref =~ s/^\n+//;
        $$ref =~ s/\s+$//;
        if ($addNL && $$ref) {
            $$ref .= "\n";
        }

        # Wir brauchen uns nur mit dem String befassen, wenn
        # das erste Zeichen ein Whitespacezeichen ist. Wenn dies nicht
        # der Fall ist, existiert keine Einrückung.

        if ($$ref =~ /^\s/) {
            my $ind;
            while ($$ref =~ /^([ \t]*)(.?)/gm) {
                next if length $2 == 0; # leere Zeile oder nur Whitespace
                $ind = $1 if !defined $ind || length $1 < length $ind;
                last if !$ind;
            }
            $$ref =~ s/^$ind//gm if $ind;
        }
    }

    return ref $arg? (): $$ref;
}

# -----------------------------------------------------------------------------

=head1 AUTHOR

Frank Seitz, L<http://fseitz.de/>

=head1 COPYRIGHT

Copyright (C) 2015 Frank Seitz

=cut

# -----------------------------------------------------------------------------

1;

# eof
