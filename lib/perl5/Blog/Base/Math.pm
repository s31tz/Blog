package Blog::Base::Math;
use base qw/Blog::Base::Object/;

# Generated by CoTeDo - DO NOT EDIT!

use strict;
use warnings;

use Math::Trig ();
use Scalar::Util ();
use POSIX ();

# -----------------------------------------------------------------------------

=encoding utf8

=head1 NAME

Blog::Base::Math - Mathematische Funktionen

=head1 BASE CLASS

L<Blog::Base::Object>

=head1 METHODS

=head2 pi() - Liefere PI

=head3 Synopsis

    $pi = $class->pi;

=cut

# -----------------------------------------------------------------------------

sub pi {
    return 4*CORE::atan2(1,1);
}

# -----------------------------------------------------------------------------

=head2 degreeToRad() - Wandele Grad in Bogenmaß (rad)

=head3 Synopsis

    $rad = $class->degreeToRad($degree);

=cut

# -----------------------------------------------------------------------------

sub degreeToRad {
    my ($class,$degree) = @_;
    return $degree*$class->pi/180;
}

# -----------------------------------------------------------------------------

=head2 radToDegree() - Wandele Bogenmaß (rad) in Grad

=head3 Synopsis

    $degree = $class->radToDegree($rad);

=cut

# -----------------------------------------------------------------------------

sub radToDegree {
    my ($class,$rad) = @_;
    return 180/$class->pi*$rad;
}

# -----------------------------------------------------------------------------

=head2 geoToDegree() - Wandele Geo-Ortskoordinate in dezimale Gradangabe

=head3 Synopsis

    $dezDeg = $class->geoToDegree($deg,$min,$sec,$dir);

=head3 Description

Wandele eine geographische Ortsangabe in Grad, Minuten, Sekunden,
Himmelsrichtung in eine dezimale Gradzahl und liefere diese zurück.

=head3 Example

    50 6 44 N -> 50.11222
    50 6 44 S -> -50.11222

=cut

# -----------------------------------------------------------------------------

sub geoToDegree {
    my ($class,$deg,$min,$sec,$dir) = @_;

    $deg = $deg + $min/60 + $sec/3600;

    if ($dir) {
        if ($dir eq 'N' || $dir eq 'E') {
            # nixtun
        }
        elsif ($dir eq 'S' || $dir eq 'W') {
            $deg = -$deg;
        }
        else {
            $class->throw(
                q{MATH-00001: Unbekannte Himmelsrichtung},
                Direction=>$dir,
            );
        }
    }

    return $deg;
}

# -----------------------------------------------------------------------------

=head2 geoDistance() - Entfernung zw. zwei Punkten auf der Erdoberfäche

=head3 Synopsis

    $km = $class->geoDistance($lat1,$lon1,$lat2,$lon2);

=head3 Description

Berechne die Entfernung zwischen den beiden Geokoordinaten ($lat1,$lon1)
und (lat2,$lon2) und liefere die Distanz in Kilometern zurück. Die Angabe
der Geokoordinaten ist in Grad.

Der Berechnung liegt die Formel zugrunde:

    km = 1.852*60*180/pi*acos(
        sin($lat1*pi/180)*sin($lat2*pi/180)+
        cos($lat1*pi/180)*cos($lat2*pi/180)*cos(($lon2-$lon1)*pi/180)
    )

=head3 Examples

Abstand zw. zwei Längengraden (359. und 360.) am Äquator:

    sprintf '%.2f',Blog::Base::Math->geoDistance(0,359,0,360);
    # -> 111.12

Abstand zw. zwei Längengraden am Pol:

    Blog::Base::Math->geoDistance(90,359,90,360);
    # -> 0

=head3 See Also

=over 2

=item *

L<Prof. Dirk Reichhardt - Hinweise zur Berechnung von Abständen|http://wwwlehre.dhbw-stuttgart.de/~reichard/content/vorlesungen/lbs/uebungen/abstandsberechnung.pdf>

=item *

L<Blog Martin Kompf - Entfernungsberechnung|http://www.kompf.de/gps/distcalc.html>

=back

=cut

# -----------------------------------------------------------------------------

sub geoDistance {
    my ($class,$lat1,$lon1,$lat2,$lon2) = @_;

    # Wir rechnen im Bogenmaß

    $lat1 = $class->degreeToRad($lat1);
    $lon1 = $class->degreeToRad($lon1);
    $lat2 = $class->degreeToRad($lat2);
    $lon2 = $class->degreeToRad($lon2);

    return 1.852*60*$class->radToDegree(Math::Trig::acos(
        sin($lat1)*sin($lat2)+cos($lat1)*cos($lat2)*cos($lon2-$lon1)));

    # 6371
    # 6366.7
    #return 6371*Math::Trig::acos(sin($lat1)*sin($lat2)+
    #    cos($lat1)*cos($lat2)*cos($lon2-$lon1));
}

# -----------------------------------------------------------------------------

=head2 latitudeDistance() - Abstand zwischen zwei Längengraden

=head3 Synopsis

    $km = $class->latitudeDistance($lat);

=head3 Description

Liefere den Abstand zwischen zwei Längengraden bei Breitengrad $lat.
Die Methode ist eigentlich nicht nötig, da sie einen Spezialfall der
Mehode geoDistance() behandelt. Die Formel stammt von Herrn Petersen.

=cut

# -----------------------------------------------------------------------------

sub latitudeDistance {
    my ($class,$lat) = @_;

    $lat = $class->degreeToRad($lat); # Breite im Bogenmaß
    my $d = $class->degreeToRad(1);   # 1 Grad im Bogenmaß

    return 1.852*60*$class->radToDegree(
        Math::Trig::acos((sin($lat)**2+cos($lat)**2*cos($d))));
}

# -----------------------------------------------------------------------------

=head2 normalizeNumber() - Normalisiere Zahldarstellung

=head3 Synopsis

    $x = $class->normalizeNumber($x);

=head3 Description

Entferne unnötige Nullen von einer Zahl, forciere als Dezimaltrennzeichen
einen Punkt (anstelle eines Komma) und liefere das Resultat zurück.

=head3 Example

    123.456000 -> 123.456
    70.00 -> 70
    0.0 -> 0
    -0.0 -> 0
    007 -> 7
    23,7 -> 23.7

=cut

# -----------------------------------------------------------------------------

sub normalizeNumber {
    my ($class,$x) = @_;

    # Wandele Komma in Punkt
    $x =~ s/,/./;

    # Entferne führende 0en
    $x =~ s/^(-?)0+(?=\d)/$1/;

    if (index($x,'.') >= 0) {
        # Bei einer Kommazahl entferne 0en und ggf. Punkt am Ende
        $x =~ s/\.?0+$//;
    }

    if ($x eq '-0') {
        $x = 0;
    }

    return $x;
}

# -----------------------------------------------------------------------------

=head2 interpolate() - Ermittele Wert durch lineare Interpolation

=head3 Synopsis

    $y = $class->interpolate($x0,$y0,$x1,$y1,$x);

=head3 Returns

Float

=head3 Description

Berechne durch lineare Interpolation den Wert y=f(x) zwischen
den gegebenen Punkten y0=f(x0) und y1=f(x1) und liefere diesen zurück.

Siehe: L<http://de.wikipedia.org/wiki/Interpolation_%28Mathematik%29#Lineare_Interpolation>

=cut

# -----------------------------------------------------------------------------

sub interpolate {
    my ($class,$x0,$y0,$x1,$y1,$x) = @_;
    return $y0+($y1-$y0)/($x1-$x0)*($x-$x0);
}

# -----------------------------------------------------------------------------

=head2 isNumber() - Prüfe, ob Skalar eine Zahl darstellt

=head3 Synopsis

    $bool = $class->isNumber($str);

=cut

# -----------------------------------------------------------------------------

sub isNumber {
    return Scalar::Util::looks_like_number($_[1])? 1: 0;
}

# -----------------------------------------------------------------------------

=head2 roundTo() - Runde Zahl auf n Nachkommastellen

=head3 Synopsis

    $y = $class->roundTo($x,$n);
    $y = $class->roundTo($x,$n,$normalize);

=head3 Description

Runde $x auf $n Nachkommastellen und liefere das Resultat zurück.

Ist $normalize "wahr", wird die Zahl nach der Rundung mit
normalizeNumber() normalisiert.

Bei $n > 0 rundet die Methode mittels

    $y = sprintf '%.*f',$n,$x;

bei $n == 0 mittels roundToInt().

=cut

# -----------------------------------------------------------------------------

sub roundTo {
    my ($class,$x,$n,$normalize) = @_;

    if ($n == 0) {
        return $class->roundToInt($x);
    }

    $x = sprintf '%.*f',$n,$x;
    if ($normalize) {
        $x = $class->normalizeNumber($x);
    }

    return $x;
}

# -----------------------------------------------------------------------------

=head2 roundToInt() - Runde Zahl zu Ganzer Zahl (Integer)

=head3 Synopsis

    $n = $class->roundToInt($x);

=head3 Description

Runde Zahl $x zu ganzer Zahl und liefere das Resultat zurück, nach
folgender Regel:

Für Nachkommastellen < .5 runde ab, für Nachkommastellen >= .5 runde auf.
Für negative $x ist es umgekehrt.

Folgender Ansatz funktioniert nicht

    $n = sprintf '%.0f',$x;

denn dieser gibt inkonsistente Ergebnisse

    0.5 => 0
    1.5 => 2
    2.5 => 2

=cut

# -----------------------------------------------------------------------------

sub roundToInt {
    return $_[1] > 0? int($_[1]+0.5): -int(-$_[1]+0.5);
}

# -----------------------------------------------------------------------------

=head2 roundMinMax() - Runde Breichsgrenzen auf nächsten geeigneten Wert

=head3 Synopsis

    ($minRounded,$maxRounded) = $class->roundMinMax($min,$max);

=head3 Description

Die Methode rundet $min ab und $max auf, so dass geeignete
Bereichsgrenzen für eine Diagrammskala entstehen.

Sind $min und $max gleich, schaffen wir einen künstlichen Bereich
($min-1,$max+1).

Die Rundungsstelle leitet sich aus der Größe des Bereichs
$max-$min her.

=head3 Examples

8.53, 8.73 -> 8.5, 8.8

8.53, 8.53 -> 7, 10

=cut

# -----------------------------------------------------------------------------

sub roundMinMax {
    my ($class,$min,$max) = @_;

    if ($min == $max) {
        # Sind Minimum und Maximum gleich, schaffen wir einen
        # künstlichen Bereich

        $min -= 1;
        $max += 1;
    }

    my $delta = $max-$min;
    for (0.0001,0.001,0.01,0.1,1,10,100,1_000,10_000,100_000) {
        if ($delta < $_) {
            my $step = $_/10;
            $min = POSIX::floor($min/$step)*$step;
            $max = POSIX::ceil($max/$step)*$step;
            last;
        }
    }

    return ($min,$max)
}

# -----------------------------------------------------------------------------

=head2 valueToPixelFactor() - Umrechnungsfaktor Wertebereich in Pixelkoordinaten

=head3 Synopsis

    $factor = $class->valueToPixelFactor($length,$min,$max)

=head3 Returns

Faktor

=head3 Description

Liefere den Faktor für die Umrechung von Wertebereich in Pixelkoordinaten.
Die Werte werden transformiert auf einen Bildschirmabschnitt
der Länge $length, dessen Randpunkte den Werten $min und $max
entsprechen.

=cut

# -----------------------------------------------------------------------------

sub valueToPixelFactor {
    my ($class,$size,$min,$max) = @_;
    return ($size-1)/($max-$min);
}

# -----------------------------------------------------------------------------

=head2 pixelToValueFactor() - Umrechnungsfaktor von Pixel in Wertebereich

=head3 Synopsis

    $factor = $class->pixelToValueFactor($length,$min,$max);

=head3 Returns

Faktor

=head3 Description

Liefere den Faktor für die Umrechung von Pixel in Werte
entlang eines Bildschirmabschnitts der Länge $length, dessen Randpunkt
dem Werteberich $min und $max entsprechen.

=cut

# -----------------------------------------------------------------------------

sub pixelToValueFactor {
    my ($class,$length,$min,$max) = @_;
    return 1/R1::Math->valueToPixelFactor($length,$min,$max);
}

# -----------------------------------------------------------------------------

=head2 valueToPixelX() - Transformiere Wert in X-Pixelkoordinate

=head3 Synopsis

    $x = $class->valueToPixelX($width,$xMin,$xMax,$xVal);

=head3 Alias

valueToPixel()

=head3 Description

Transformiere Wert $xVal in eine Pixelkoordinate auf einer X-Pixelachse
der Breite $width. Das Minimum des Wertebereichs ist $xMin und das Maximum
ist $xMax. Die gelieferten Werte liegen im Bereich 0 .. $width-1.

=cut

# -----------------------------------------------------------------------------

sub valueToPixelX {
    my ($class,$width,$xMin,$xMax,$xVal) = @_;
    return sprintf '%.0f',($xVal-$xMin)*($width-1)/($xMax-$xMin);
}

{
    no warnings 'once';
    *valueToPixel = \&valueToPixelX;
}

# -----------------------------------------------------------------------------

=head2 valueToPixelY() - Transformiere Wert in Y-Pixelkoordinate

=head3 Synopsis

    $y = $class->valueToPixelY($height,$yMin,$yMax,$yVal);

=head3 Description

Transformiere Wert $yVal in eine Pixelkoordinate auf einer Y-Pixelachse
der Höhe $height. Das Minimum des Wertebereichs ist $yMin und das Maximum
ist $yMax. Die gelieferten Werte liegen im Bereich $height-1 .. 0.

=cut

# -----------------------------------------------------------------------------

sub valueToPixelY {
    my ($class,$height,$yMin,$yMax,$yVal) = @_;
    return sprintf '%.0f',$height-1-($yVal-$yMin)*($height-1)/($yMax-$yMin);
}

# -----------------------------------------------------------------------------

=head2 intToWord() - Wandele positive ganze Zahl in Wort über Alphabet

=head3 Synopsis

    $word = $this->intToWord($n);
    $word = $this->intToWord($n,$alphabet);

=head3 Returns

Zeichenkette

=head3 Description

Wandele positive ganze Zahl $n in ein Wort über dem Alphabet
$alphabet und liefere dieses zurück. Für 0 liefere
einen Leerstring.

Das Alphabet, über welchem die Worte gebildet werden, wird in Form
einer Zeichenkette angegeben, in der jedes Zeichen einmal
vorkommt. Per Default wird das Alphabet

    'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

verwendet. Die Funktion implementiert folgende Abbildung:

    0 -> ''
    1 -> 'A'
    2 -> 'B'
    
    ...
    26 -> 'Z'
    27 -> 'AA'
    28 -> 'AB'
    ...
    52 -> 'AZ'
    53 -> 'BA'
    ...

=cut

# -----------------------------------------------------------------------------

sub intToWord {
    my $this = shift;
    my $n = shift;
    my $alphabet = shift || 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    my $l = length $alphabet;

    my $word = '';
    my $m = $n; # warum dies?

    while ($m) {
        my $mod = $m%$l;
        $word = substr($alphabet,$mod-1,1).$word;
        $m = POSIX::floor($m/$l);
        $m -= 1 if $mod == 0;
    }

    return $word;
}

# -----------------------------------------------------------------------------

=head1 AUTHOR

Frank Seitz, L<http://fseitz.de/>

=head1 COPYRIGHT

Copyright (C) 2009-2015 Frank Seitz

=cut

# -----------------------------------------------------------------------------

1;

# eof
