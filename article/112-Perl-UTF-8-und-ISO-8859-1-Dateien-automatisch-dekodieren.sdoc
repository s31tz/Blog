# Date: 2015-07-10

%Document:
  title="Perl: UTF-8 und ISO-8859-1 Dateien erkennen und automatisch dekodieren"
  generateAnchors=0
  utf8=1
  minLnWidth=2

# id=124

%Figure: file="IMGDIR/perl-130x65.png" \
    width=94 height=47 url="http://www.perl.org/"

Das in Westeuropa weit verbreitete Character Encoding Latin1
(ISO-8859-1) wird zunehmend durch das umfassendere Unicode
(insbesondere UTF-8) abgelöst. Oftmals treten daher Textdateien -
z.B. Quelltexte - in verschiedenen Encodings auf. Wenn ein- und
dasselbe Programm mit verschiedenen Encodings umgehen soll, wirft dies
ein Problem auf. Denn um eine Textdatei korrekt verarbeiten zu können,
muss der Text gemäß seines Encodings dekodiert werden. Das Encoding
ist der Datei von außen aber nicht anzusehen.

Idealerweise sollte ein Programm sowohl mit ISO-8859-1 als auch mit
UTF-8 umgehen können, und zwar am besten so, dass das Encoding
I{nicht} explizit angegeben werden muss.

Lässt sich dies realisieren?

Ja, indem das Programm sich den Inhalt der Datei "ansieht", entscheidet,
welches Encoding vorliegt und den Text entsprechend dekodiert.

Im Falle von Perl kann hierfür das Modul
U{"http://perldoc.perl.org/Encode/Guess.html",text="Encode::Guess"}
genutzt werden. Es ist Teil des Perl-Core und damit in jeder
Perl-Installation enthalten. Es wird mit

  %Code: listing=1 filter="./blog-highlight perl %FORMAT%"
  use Encode::Guess;
  .

geladen.

Wir nutzen die objektorientierte Schnittstelle des Moduls. Theoretisch
sollte folgender Sechszeiler die Aufgabe erledigen:

  %Code: listing=1 filter="./blog-highlight perl %FORMAT%"
  Encode::Guess->set_suspects('iso-8859-1');
  my $dec = Encode::Guess->guess($text);
  if (!ref $dec) {
      die "ERROR: $dec\n";
  }
  $text = $dec->decode($text);
  .

Erläuterung:

[Zeile 1:]
  Wir definieren C{iso-8859-1} als Encoding, das I{zusätzlich} zu den
  Default-Encodings C{ascii}, C{utf8}, C{UTF-16/32 mit BOM},
  geprüft werden soll.

[Zeile 2:]
  Der Inhalt der Datei steht auf der Variable C{$text} (das Einlesen hat
  vorher stattgefunden und ist hier nicht wiedergegeben). Die Methode
  C{guess()} versucht das Encoding zu ermitteln und liefert im
  Erfolgsfall ein passendes Decoder-Objekt. Im Fehlerfall liefert
  die Methode eine Fehlermeldung (also eine Zeichenkette).

[Zeile 3-5:]
  Fehlerbehandlung. Falls wir eine Fehlermeldung erhalten haben, brechen
  wir mit einer Exception ab. Zwei mögliche Fehlerfälle sind:

  1. Der Text entspricht I{keinem} der geprüften Encodings.
  2. I{Mehr als eines} der Encodings kommt infrage.

[Zeile 6:]
  Es wurde ein Decoder-Objekt geliefert, also ein Encoding
  I{eindeutig} erkannt. Wir dekodieren den Text mit dem Decoder-Objekt.

Leider funktioniert diese Implementierung nicht!

Denn wir stellen folgendes fest:

* Ist die Datei ISO-8859-1 kodiert, gelingt das Dekodieren.

* Ist die Datei UTF-8 kodiert, bricht der Code mit der Fehlermeldung

    ERROR: utf8 or iso-8859-1

  ab, d.h. der Methode C{guess()} war es nicht möglich, das Encoding
  eindeutig zu bestimmen.

Woran liegt das?

Die Ursache für den Abbruch ist, dass jede UTF-8-Datei I{formal}
auch eine ISO-8859-1-Datei ist. Denn I{jede} Datei ist I{formal} eine
ISO-8859-1-Datei, selbst eine Binärdatei wie z.B. ein JPEG-Bild. Das
liegt daran, dass ISO-8859-1 ein Ein-Byte-Encoding ist, bei dem alle
256 Werte belegt sind.

Es ist also fruchtlos und hinderlich, mit C{Encode::Guess} auf
ISO-8859-1 testen zu wollen.

Ist die Unterscheidung von UTF-8 und ISO-8859-1 also nicht möglich?

Doch, sie ist möglich, wenn auch nicht nach den rein formalen Kriterien,
die C{Encode::Guess} anwendet. Denn auch wenn UTF-8 formal gültiges
ISO-8859-1 ist, gilt nicht die Umkehrung, dass jeder ISO-8859-1
Text valides UTF-8 darstellt. Es ist sogar I{sehr unwahrscheinlich},
dass ein realer ISO-8859-1 Text, gleichzeitig valides UTF-8
ergibt. Unter Berücksichtigung dieser Tatsache können wir die
Erkennung von ISO-8859-1 und UTF-8 verbessern:

  %Code: listing=1 filter="./blog-highlight perl %FORMAT%"
  my $dec = Encode::Guess->guess($text);
  if (ref $dec) {
      $text = $dec->decode($text);
  }
  elsif ($dec =~ /No appropriate encodings found/i) {
      $text = Encode::decode('iso-8859-1',$text);
  }
  else {
      die "ERROR: $dec\n";
  }
  .

Erläuterung:

[Zeile 1:]
  Der Dateiinhalt wird auf die Default-Encodings C{ascii}, C{utf8},
  C{UTF-16/32 mit BOM} - also Unicode - geprüft.

[Zeile 2-4:]
  Falls UTF-8 erkannt wurde (oder eines der anderen Unicode-Encodings)
  nutzen wir das gelieferte Encoder-Objekt um den Text zu dekodieren.

[Zeile 5-7:]
  Falls kein Unicode-Encoding erkannt wurde, muss es sich um eine ISO-8859-1
  Datei handeln, denn andere Encodings erwarten wir nicht. Wir dekodieren
  den Text ohne Encoder-Objekt mit der Funktion C{Encode::decode()}.

[Zeile 8-10:]
  Falls ein sonstiger Fehler eingetreten ist, brechen wir mit
  einer Exception ab.

Dieser Ansatz ("Wenn etwas wie UTF-8 aussieht, ist es auch UTF-8, sonst
betrachten wir es als ISO-8859-1") funktioniert.

Das Ganze als vollständige Implementierung einer Perl-Klasse C{File}
mit einer einzelnen Methode C{decode()}:

  %Code: listing=1 filter="./blog-highlight perl %FORMAT%"
  package File;

  use strict;
  use warnings;

  use Encode::Guess ();

  # ---------------------------------------------------------------------------

  =encoding utf8

  =head1 NAME

  File - Klasse mit Datei-Operationen

  =head1 METHODS

  =head2 decode() - Lies und dekodiere eine Textdatei

  =head3 Synopsis

      $text = $class->decode($file);

  =head3 Description

  Lies Textdatei $file und liefere den dekodierten Inhalt zurück.
  Als Character Encoding erwarten wir Unicode (speziell UTF-8) oder
  Latin1 (ISO-8859-1).

  =cut

  # ---------------------------------------------------------------------------

  sub decode {
      my ($class,$file) = @_;

      # Datei einlesen

      local $/ = undef;
      open my $fh,'<',$file or die "ERROR: open failed: $file ($!)\n";
      my $text = <$fh>;
      close $fh;

      # Encoding ermitteln und Text dekodieren

      my $dec = Encode::Guess->guess($text);
      if (ref $dec) {
          # Wir dekodieren Unicode
          $text = $dec->decode($text);
      }
      elsif ($dec =~ /No appropriate encodings found/i) {
          # Erwarteter Fehler: Wir dekodieren Latin1
          $text = Encode::decode('iso-8859-1',$text);
      }
      else {
          # Unerwarteter Fehler
          die "ERROR: $dec\n";
      }

      return $text;
  }

  # ---------------------------------------------------------------------------

  =head1 AUTHOR

  Frank Seitz, L<http://fseitz.de/>

  =head1 COPYRIGHT

  Copyright © 2015 Frank Seitz

  =head1 LICENSE

  This code is free software. You can redistribute it and/or modify
  it under the same terms as Perl itself.

  =cut

  # ---------------------------------------------------------------------------

  1;

  # eof
  .

= Links

* U{"http://perldoc.perl.org/Encode/Guess.html",text="Encode::Guess"}

# eof
